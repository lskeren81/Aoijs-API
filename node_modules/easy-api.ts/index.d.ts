import { Application, Request, Response } from "express"
import { TypedEmitter } from "tiny-typed-emitter";
import { FunctionBuilder } from "./src/classes/builder";
import { SKRSContext2D } from "@napi-rs/canvas";

export type AllowedDatabases = 'replit' | 'mongo' | 'quickdb' | 'default'

export interface ConstructorOptions {
    port: number
    spaces?: number
    reverseReading?: boolean
    database?: {
        enabled?: boolean
        type?: AllowedDatabases
        mongoUrl?: string
    }
}

export interface ObjectWithFuncs {
    [key: string]: FnD;
};

export interface field {
    value: string;
    overs: FnD[];
};

export interface FnD {
    resolve_fields: (...args: any) => any;
    resolve_field: (...args: any) => any;
    fields: null | field[];
    inside: null | string;
    total: string;
    name: string;
    id: string;
};

export interface Events {
    ready: (app: Application) => void;
    error: (error: Error) => void;
}

export interface Route {
    path: string
    details?: Record<string, any>
    code: string
}

class Compiler {
    public functions: string[]
    public regex: RegExp | null
    public matched: ObjectWithFuncs | null
    public result: string
    public code: null | string
    constructor(code: string)
    set_functions(fns: string[]): ThisType
    set_code(code: string): string
    match(): ObjectWithFuncs | undefined
}

export interface Data {
    app: Application
    code: string
    func: FnD | null
    req: Request
    res: Response
    _: Record<string, any>
    break: boolean
    routes: Endpoints
    interpreter: Interpreter
    compiler: Compiler
}

export interface FunctionBuilderData {
    name: string,
    extra?: Record<string, any>
}

export interface SourceFunction {
    data: FunctionBuilderData | FunctionBuilder
    code: (data: Data) =>  Promise<{ code: string, _?: Record<string, T> } | void>
}

export class Interpreter {
    constructor(app: Application, routes: Endpoints, db: any)
    public functions: SourceFunction[]
    public app: Application
    public reverseReading: boolean
    public db: any
    public compiler: Compiler
    public resolve_fields(data: Data): Promise<FnD | undefined>
    public resolve_field(data: Data, index: number): Promise<FnD>
    public run_function(fn: FnD, d: Data, is_over?: boolean): Promise<void>
    public parse(text: string, req: Request, res: Response, d?: Data): Promise<Data | undefined>
    public addFunction(func: SourceFunction)
    public getFunction(func: string): Record<string, any> | null
    private load(): void
}

export const Utils = {
    /**
     * Parse a string and check its original data type
     * @param text The string to parse
     */
    parse(text: string): any;,
    /**
     * Sends a warn to the console.
     * @param error The error itself.
     * @param data The source.
     */
    Warn(error: string, data: string): void;,
    /**
     * Checks if this string/number is a valid number resolvable.
     * @param num The text to check if its a number.
     */
    isNumber(num: string): boolean;,
    /**
     * Convert a string to boolean.
     * @param str The string to validate as boolean.
     */
    booleanify(str: string): boolean;,
    /**
     * Resolve a condition inside a string.
     * @param condition The string conditional.
     */
    condition(condition: string): boolean | null;,
    /**
     * Convert a string to json.
     * @param json The JSON/Object string.
     */
    loadObject(json: string): Record<string, any> | null;,
    /**
     * Checks if a string is a valid color code (hex) resolvable.
     * @param str The color code.
     */
    isValidHex(str: string): boolean;,
    /**
     * Cuts a molde in the next drawing of the canvas.
     * @param ctx The canvas context.
     * @param x X position.
     * @param y Y position.
     * @param width Width.
     * @param height Height.
     * @param radius The circle radius.
     */
    molde(ctx: SKRSContext2D, x: number, y: number, width: number, height: number, radius: number): void
}

export class Endpoints {
    constructor(app: Application)
    public app: Application
    public routes: Route[]
    public getRoutes(): Route[]
    /**
     * Add a route to the API.
     * @param route The route data.
     * @example
     * module.exports = {
     *      path: '/endpoint',
     *      code: `
     * $send[200;json;{text: "hello"}]
     * `
     * }
     */
    public add(route: Route): void
    /**
     * Load a routes directory (Handler)
     * @param dir The directory path
     * @example
     * <API>.routes.load('./routes')
     */
    public async load(dir: string): Promise<void>
}

export class API extends TypedEmitter<Events> {
    public port: number
    public db: any
    public app: Application
    public interpreter: Interpreter
    public routes: Endpoints
    constructor(options: ConstructorOptions)
    /**
     * Set the spaces in the objects.
     * @param howmany The number of breaklines in the JSON objects.
     * @deprecated Use constructor object instead.
     */
    public setSpaces(howmany: number): void;
    /**
     * Set a 404 page (using code)
     * @param code The code to execute instead 'cannot get /X'
     */
    public set404(code: string): void;
    /**
     * Starts the API.
     */
    public connect(): void
}

export default { API, FunctionBuilder, Utils }

declare global {
    interface String {
        /**
         * Replace last argument from a string.
         */
        resolve(What: string, Replacement: string): string
        after(): string | null
        escape(): string | null
        unescape(): string | null
        replaceLast(p: string | RegExp, r?: string): string
    }
}